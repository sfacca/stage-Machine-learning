"#= none:2 =# Core.@doc ""    findfunc(expr::Expr, name::Symbol)\n\nfindfunc walks the AST of `expr` to find the definition of function called `name`.\n\nThis function returns a reference to the original expression so that you can modify it inplace\nand is intended to help users rewrite the definitions of functions for generating new models.\n"" function findfunc(expr::Expr, name::Symbol)
        #= none:9 =#
        #= none:10 =#
        try
            #= none:11 =#
            expr.head
        catch
            #= none:13 =#
            return nothing
        end
        #= none:16 =#
        if expr.head == :module
            #= none:17 =#
            return findfunc(expr.args[3], name)
        end
        #= none:19 =#
        if expr.head == :function
            #= none:21 =#
            if (expr.args[1]).args[1] == name
                #= none:22 =#
                return expr
            end
            #= none:24 =#
            return findfunc(expr.args, name)
        end
        #= none:26 =#
        if expr.head == :(=)
            #= none:27 =#
            if expr.args[1] isa Symbol
                #= none:28 =#
                return nothing
            end
            #= none:31 =#
            if (expr.args[1]).head == :call
                #= none:33 =#
                if (expr.args[1]).args[1] == name
                    #= none:34 =#
                    return expr
                end
                #= none:36 =#
                return findfunc(expr.args, name)
            end
        end
        #= none:39 =#
        if expr.head == :block
            #= none:40 =#
            return findfunc(expr.args, name)
        end
        #= none:42 =#
        return nothing
    end"	./sample\findfunc.jl
"function findfunc(expr::LineNumberNode, s::Symbol)
    #= none:45 =#
    #= none:46 =#
    return nothing
end"	./sample\findfunc.jl
"function findfunc(args::Vector{Any}, name::Symbol)
    #= none:49 =#
    #= none:50 =#
    return filter((x->begin
                    #= none:50 =#
                    x != nothing
                end), [findfunc(a, name) for a = args])
end"	./sample\findfunc.jl
"walk(x, inner, outer) = begin
        #= none:54 =#
        outer(x)
    end"	./sample\findfunc.jl
"walk(x::Expr, inner, outer) = begin
        #= none:55 =#
        outer(Expr(x.head, map(inner, x.args)...))
    end"	./sample\findfunc.jl
"#= none:57 =# Core.@doc ""    findassign(expr::Expr, name::Symbol)\n\nfindassign walks the AST of `expr` to find the assignments to a variable called `name`.\n\nThis function returns a reference to the original expression so that you can modify it inplace\nand is intended to help users rewrite expressions for generating new models.\n\nSee also: [`findfunc`](@ref).\n"" function findassign(expr::Expr, name::Symbol)
        #= none:66 =#
        #= none:68 =#
        matches = Expr[]
        #= none:69 =#
        g(y::Any) = begin
                #= none:69 =#
                :(())
            end
        #= none:70 =#
        f(x::Any) = begin
                #= none:70 =#
                :(())
            end
        #= none:71 =#
        f(x::Expr) = begin
                #= none:71 =#
                #= none:72 =#
                if x.head == :(=)
                    #= none:73 =#
                    if x.args[1] == name
                        #= none:74 =#
                        push!(matches, x)
                        #= none:75 =#
                        return x
                    end
                end
                #= none:79 =#
                walk(x, f, g)
            end
        #= none:81 =#
        walk(expr, f, g)
        #= none:82 =#
        return matches
    end"	./sample\findfunc.jl
"function replacevar(expr::Expr, name::Symbol, newname::Symbol)
    #= none:85 =#
    #= none:86 =#
    g(x::Any) = begin
            #= none:86 =#
            x
        end
    #= none:87 =#
    f(x::Any) = begin
            #= none:87 =#
            x
        end
    #= none:88 =#
    f(x::Symbol) = begin
            #= none:88 =#
            if x == name
                newname
            else
                x
            end
        end
    #= none:89 =#
    f(x::Expr) = begin
            #= none:89 =#
            walk(x, f, g)
        end
    #= none:90 =#
    return walk(expr, f, g)
end"	./sample\findfunc.jl
"function replacevar(expr::Expr, tr::Dict{Symbol, Any})
    #= none:93 =#
    #= none:94 =#
    g(x::Any) = begin
            #= none:94 =#
            x
        end
    #= none:95 =#
    f(x::Any) = begin
            #= none:95 =#
            x
        end
    #= none:96 =#
    f(x::Symbol) = begin
            #= none:96 =#
            get(tr, x, x)
        end
    #= none:97 =#
    f(x::Expr) = begin
            #= none:97 =#
            walk(x, f, g)
        end
    #= none:98 =#
    return walk(expr, f, g)
end"	./sample\findfunc.jl
"#= none:2 =# Core.@doc ""    postwalk(f, expr)\nApplies `f` to each node in the given expression tree, returning the result.\n`f` sees expressions *after* they have been transformed by the walk. See also\n`prewalk`.\n"" postwalk(f, x) = begin
            #= none:8 =#
            walk(x, (x->begin
                        #= none:8 =#
                        postwalk(f, x)
                    end), f)
        end"	./sample\macrotools.jl
"#= none:10 =# Core.@doc ""    prewalk(f, expr)\nApplies `f` to each node in the given expression tree, returning the result.\n`f` sees expressions *before* they have been transformed by the walk, and the\nwalk will be applied to whatever `f` returns.\nThis makes `prewalk` somewhat prone to infinite loops; you probably want to try\n`postwalk` first.\n"" prewalk(f, x) = begin
            #= none:18 =#
            walk(f(x), (x->begin
                        #= none:18 =#
                        prewalk(f, x)
                    end), identity)
        end"	./sample\macrotools.jl
"replace(ex, s, s′) = begin
        #= none:20 =#
        prewalk((x->begin
                    #= none:20 =#
                    if x == s
                        s′
                    else
                        x
                    end
                end), ex)
    end"	./sample\macrotools.jl
"#= none:22 =# Core.@doc ""    inexpr(expr, x)\nSimple expression match; will return `true` if the expression `x` can be found\ninside `expr`.\n    inexpr(:(2+2), 2) == true\n"" function inexpr(ex, x)
        #= none:28 =#
        #= none:29 =#
        result = false
        #= none:30 =#
        postwalk(ex) do y
            #= none:31 =#
            if y == x
                #= none:32 =#
                result = true
            end
            #= none:34 =#
            return y
        end
        #= none:36 =#
        return result
    end"	./sample\macrotools.jl
"module Parsers
#= none:2 =#
#= none:3 =#
using Base.Meta
#= none:4 =#
import Base.push!
#= none:6 =#
export parsefile, defs, funcs, recurse, MetaCollector, FuncCollector, AbstractCollector, walk, inexpr, findfunc, findassign, replacevar, postwalk, prewalk, replace, inexpr
#= none:11 =#
include(""macrotools.jl"")
#= none:12 =#
include(""findfunc.jl"")
#= none:14 =#
#= none:14 =# Core.@doc ""    parsefile(path)\n\nread in a julia source file and parse it.\n\nNote: If the top level is not a simple expression or module definition the file is wrapped in a Module named modprefix.\n"" function parsefile(path, modprefix = ""Modeling"")
        #= none:20 =#
        #= none:21 =#
        s = read(path, String)
        #= none:25 =#
        try
            #= none:26 =#
            expr = Base.Meta.parse(s)
            #= none:27 =#
            return expr
        catch
            #= none:29 =#
            s = ""module $(modprefix)\n$(s) \nend #module $(modprefix)""
            #= none:30 =#
            expr = Base.Meta.parse(s)
            #= none:31 =#
            return expr
        end
    end
#= none:35 =#
#= none:35 =# Core.@doc ""    AbstractCollector\n\nsubtypes of AbstractCollector support extracting and collecting information\nfrom input sources.\n"" abstract type AbstractCollector end
#= none:43 =#
#= none:43 =# Core.@doc ""    FuncCollector{T} <: AbstractCollector\n\ncollects function definitions and names\n"" struct FuncCollector{T} <: AbstractCollector
        #= none:48 =#
        defs::T
    end
#= none:51 =#
function push!(fc::AbstractCollector, expr::LineNumberNode)
    #= none:51 =#
    #= none:52 =#
    return nothing
end
#= none:55 =#
function push!(fc::FuncCollector, expr::Expr)
    #= none:55 =#
    #= none:56 =#
    if expr.head == :function
        #= none:57 =#
        push!(fc.defs, expr.args[1] => expr.args[2])
    end
end
#= none:61 =#
#= none:61 =# Core.@doc ""   MetaCollector{T,U,V,W} <: AbstractCollector\n\ncollects multiple pieces of information such as\n\n- exprs: expressions\n- fc: functions\n- vc: variable assignments\n- modc: module imports\n"" struct MetaCollector{T, U, V, W} <: AbstractCollector
        #= none:71 =#
        exprs::V
        #= none:72 =#
        fc::T
        #= none:73 =#
        vc::U
        #= none:74 =#
        modc::W
    end
#= none:77 =#
function push!(mc::MetaCollector, expr::Expr)
    #= none:77 =#
    #= none:78 =#
    push!(mc.exprs, expr)
    #= none:79 =#
    push!(mc.fc, expr)
    #= none:80 =#
    if expr.head == :(=)
        #= none:81 =#
        #= none:81 =# @debug ""pushing into vc"" expr = expr
        #= none:82 =#
        push!(mc.vc, expr.args[1] => expr.args[2])
    elseif #= none:83 =# expr.head == :using
        #= none:84 =#
        push!(mc.modc, (expr.args[1]).args)
    else
        #= none:86 =#
        #= none:86 =# @info ""unknown expr type for metacollector""
        #= none:87 =#
        #= none:87 =# @show expr
    end
end
#= none:92 =#
#= none:92 =# Core.@doc ""    funcs(body)\n\ncollect the function definitions from a module expression.\n"" function funcs(body)
        #= none:96 =#
        #= none:97 =#
        fs = FuncCollector([])
        #= none:98 =#
        for subexpr = body
            #= none:99 =#
            push!(fs, subexpr)
        end
        #= none:101 =#
        return fs
    end
#= none:104 =#
#= none:104 =# Core.@doc ""    defs(body)\n\ncollect the function definitions and variable assignments from a module expression.\n"" function defs(body)
        #= none:108 =#
        #= none:110 =#
        mc = MetaCollector(Any[], FuncCollector([]), Any[], Any[])
        #= none:111 =#
        for expr = body
            #= none:112 =#
            push!(mc, expr)
        end
        #= none:114 =#
        return mc
    end
#= none:117 =#
function recurse(mc::AbstractCollector)
    #= none:117 =#
    #= none:118 =#
    subdefs = Any[]
    #= none:119 =#
    funcdefs = mc.fc.defs
    #= none:120 =#
    #= none:120 =# @show funcdefs
    #= none:121 =#
    for def = funcdefs
        #= none:122 =#
        funcname = def[1]
        #= none:123 =#
        funcquote = def[2]
        #= none:124 =#
        push!(subdefs, funcname => defs(funcquote.args))
    end
    #= none:126 =#
    return subdefs
end
end"	./sample\parse.jl
